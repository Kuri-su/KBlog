# Golang Web 程序 客户端压力测试要点

[TOC]

客户端压测时除了我们最关注的 QPS 以外, 还有 进程的 `CPU` / `MEM`, `HTTP 状态码`, `是否有 Timeout`, `响应时延`, `网卡流量` 这几个指标需要关注, 下面笔者一个一个指标来说.

## 压测的目的

在此之前,我们需要先明确一下压测的目的, 压测不是压的出最高的 QPS 就好... 还有 `各种压力下程序的表现` 和 找出 `最适合的 压力范围` 也是 压测非常重要的报告内容, 基于这些报告内容, 我们才可以 有底气的去配置 程序资源消耗 和 xxxxx 

## 指标

### QPS

这个没啥好说的, 就是 每秒处理请求数, 属于客观指标, 对于 Go Web 程序来讲, 主要的影响因素在于 CPU 和 bandwidth, 下面会讲到

对于 Golang web 程序来说, 在 CPU 满载之后, QPS 将不会继续上升. 这是一个什么概念呢, 我们看看下面这个例子.

假设 一个 `Go Web App` 在 每秒 50 并发的时候就会满载, CPU 使用率涨到 100% , qps 1000 . // TODO

那么即便我们 把压测程序的并发量 加到 100, 200 ,甚至 1000, 我们会发现 从 压测报告上看到的 QPS 将不会再上升, 都会是 1000, 但我们

在 标准库 `net/http` 的 http server 实现中, 每接受到一个请求就会新开一个 Goroutine 协程来处理. 那么当极大的并发涌入 的时候, 此时 http server 会开巨量的 Goroutine 来处理, 但 Goroutine 不是 操作系统 级别的线程,它没有办法直接从 CPU 分到时间片, 他的执行完全由 golang 本身的 协程调度器 来进行调度, 当 调度器 没有分配 时间片给 协程的时候, 此时的协程只是一段存在内存里的 代码上下文而已, 不会有任何多余的损耗. 

你可以看着下面这个图, 由于计算力有限, CPU 的计算力就相当于一个 固定大小的窗口,  CPU 的计算力窗口 在 由 Goroutine 组成的长条上滑动来完成计算范围内的 Goroutine 计算任务.

![]() 

当 Groutine 的长条 过长, 导致长条后面的 Goroutine 太久没有被分到时间片计算, 这将导致 Client 端直接 Timeout , 这也就能讲通上面为什么 并发量 持续提升, 而 QPS 不变, 请求时延 和 Timeout 请求量 跟随并发量持续提升

### MEM

通常 Goweb 程序 在运行过程中占用的  mem 是基本不会有太大或者太急速的上涨 (特殊情况除外), 如果发现 mem 占用 在 压测过程中持续上涨, 建议 用 pprof debug 一下是不是有哪里 内存泄漏了.... [pprof 的 guide 请点这里](https://kuricat.com/articles/golang-pprof-guide-sw40b) 

### 网卡流量

### 相应时延

### HTTP 状态码

### Timeout

